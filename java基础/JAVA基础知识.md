####1.面向对象和面向过程的区别

**面向过程**

> 优点：性能比面向对象高。因为面相对象 类调用需要实例化，开销比较大，比较消耗资源；比如单片机、嵌入式开发、Linux/Unix等一般都采用面向过程开发，性能是最重要的因素。
>
> 缺点：没有面向对象易维护、易复用、易扩展。

**面向对象**

> 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护。
>
> 缺点：性能比面向过程低。

#### 2.Java语言有哪些特点

> 1、简单易学；
>
> 2、面向对象（封装、继承、多态）；
>
> 3、平台无关性（Java虚拟机实现平台无关性）；
>
> 4、可靠性；
>
> 5、安全性；
>
> 6、支持多线程(C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能呢个来进行多线程程序设计，而Java语言却提高了多线程支持）。
>
> 7、支持网络编程并且很方便（Java语言诞生本身就是为了简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；
>
> 8、编译与解释并存。

#### 3.什么是JDK 什么是JRE 什么JVM 三者直接的关系与区别

> **JDK**：顾名思义它是给开发者提供的开发工具箱，是给程序开发者用的。它除了包括完整的JRE(Java Runtime Environment)，Java运行环境，还包含了其他供开发者使用的工具包。
>
> **JRE**：普通用户而只需要安装JRE来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。
>
> **JVM**：当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理、垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。
>
>
>
> **区别于联系**
>
> 1.JDK用于开发、JRE用于运行java程序；
>
> 2.JDK和JRE中都包含JVM；
>
> 3.JVM是Java编程语言的核心并且具有平台独立性。

#### 4.什么是字节码 采用字节码的最大好处是什么

> **先看下java中的编译器和解释器**
>
> java中引入了虚拟机的概念，即在机器和编译程序之间加入来一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。
>
> 编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器执行。在Java中，这种供虚拟机理解的代码叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。
>
> 每一种平台的解释器时不同的，但是实现的虚拟机时相同的。Java源程序通过编译器编译成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码发送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。
>
> Java源代码—>编译器——>jvm可执行的java字节码（即虚拟指令）-->jvm—>jvm中解释器—>机器可执行的二进制机器码-->程序运行。
>
> **采用字节码的好处：**
>
> Java语言采用字节码的方式，在一定程度上解决了传统解释型语言执行低效的问题，同时又保留了解释型语言可移植的特点。所以java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，java程序无需重新编译便可以在多重不同的计算机上运行。
>
> > 解释型语言：解释型语言，是在运行的时候将程序翻译成机器语言。解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译，专门的解释器负责在每个语句执行的时候解释程序代码。这种解释型语言每执行一次就要翻译一次，效率比较低。

####5.Java和C++的区别。

- 都是面向对象的语言，都支持封装、继承和多态。
- Java不提供指针来直接访问内存，程序内存更加安全。
- Java的类是单继承，C++支持多重继承；Java的类可以多实现。
- Java又自动内存管理机制，不需要程序员手动释放无用内存。

####6.什么是Java程序的主类 应用程序和小程序的主类有何不同。

一个程序可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main方法的类。而在Java小程序中，这个类是一个继承自系统类JApplet的Applet的子类。应用程序的主类不一定要求是public类，但是小程序的主类必须是public类。主类是Java程序执行的切入点。

#### 7.Java程序和小程序之间又哪些差别

简单来说应用程序是从主程序启动（也就是main方法）。applet小程序没有main方法，主要是嵌在浏览器页面上运行（调用init()线程或者run()来启动），嵌入浏览器这点跟flush的小游戏类似。

#### 8.字符型常量和字符串变量的区别

1.形式上：字符常量是单引号引起的一个字符，字符串变量是双引号引起来的若干个字符。

2.含义上：字符常量相当于一个整型值（ASCII值），可以参加表达式运算，字符串变量代表一个地址值。

3.占内存大小：字符常量占2个字节。（char在java钟占两个字节）

![QQ20181219-195906@2x](/Users/yanpeng/Documents/pengyand/spring-boot/images/QQ20181219-195906@2x.png)

#### 9. 构造器Constructor是否可以被override

父类的私有属性和构造方法是不可以被继承的，所以Constructor也就不能被override（重写），但是可以被overload（重载），可以你可以看到一个类中有多个构造函数的情况。

#### 10.重载和重写的区别

**重载：**发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

**重写:** 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法修饰符为private，则子类就不能重写该方法。



#### 11.Java面向对象编程三大特性：封装、继承、多态

**封装**

封装是把一个对象的属性私有化，同时提供一些可以被外界访问属性的方法，如果属性不想被外界访问，我们可以不提供发放给外界访问。但是如果一个类没有提供外界访问的方法，那么这个类也就没有什么意义了。

**继承**

继承是使用已存在的类的定义作为基础建立新类的一种技术，新类的定义是增加新的数据或者新的功能，也可以用父类的功能，但是不能选择性的继承父类。通过使用继承我们能够非常方便地复用以前的代码。

**关于继承如下3点请记住：**

​	1.子类拥有父类的非private属性和方法。

​	2.子类可以拥有自己属性和方法，即子类对父类进行扩展。

​	3.子类可以用自己的方式实现父类的方法。

**多态**

所谓多台就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行才能决定。

在java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一个方法）。



#### 12.String和StringBuffer、StringBuilder的区别是什么，String为什么是不可变的。

**可变性**

简单的说：String类中使用final关键字字符数组来保存字符串，`private final char value[]`，所以String对象是不可变的。而StringBuilder于StringBuffer都继承自 `AbstractStringBuilder`类，在 `AbstractStringBuilder`中页是使用字符数组`char[] value`保存字符串,但是没有用final关键字修饰，所以这两种对象都是可变的。

StringBuilder和StringBuffer的构造方法都是调用父类构造方法，也就是AbstracteStringBuilder实现的：

AbstractStringBuilder.java

~~~java
abstract class AbstractStringBuilder implements Appendable,CHarSequence{
    char[] value;
    int count;
    AbstractStringBuilder(){
        
    }
    AbstractStringBulder(int capacity){
        value = new char[capacity];
    }
}
~~~

**线程安全性**

String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder和StringBuffer的公共父类，定义了一些字符串的基本操作，例如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

每次对String类型进行改变的时候，都会生成一个新的String对象，然后指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%-15%左右的性能提升，但却要冒着多线程不安全的风险。

**对于三者使用的总结：**

​	1.操作少量数据：String

​	2.单线程操作字符串缓冲区下操作大量数据：StringBuilder

​	3.多线程操作字符串缓冲区下操作大量数据：StringBuffer



#### 13.自动装箱与拆箱

**装箱：** 将基本类型用它们对应的引用类型包装起来；

**拆箱：** 将包装类型转换为基本数据类型；



#### 14. 在一个静态方法内调用一个非静态成员为什么是非法的。

由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，页不可以访问非静态变量成员。



#### 15. 在Java钟定义一个不做事且没有参数的构造方法的作用

​	Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中没有参数的构造方法。因此，如果父类中只定义了有参构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时会发生错误，因为Java程序 在父类中找不到没有参数的构造方法可供执行。解决方法是在父类里加上一个不做事且没有参数的构造方法。



#### 16.import java和javax有什么区别

刚开始的时候 java API 所需的包是java开头的包，javax当时只是扩展API包来使用。然而随着时间的推移，javax逐渐的扩展成为java API的组成部分。但是将扩展从javax移到java包将是件麻烦的事，最终会破坏一堆现有的代码。因此，最终决定javax包将成为标注API的一部分。

所以实际上java和javax没有区别。



#### 17.接口和抽象类区别是什么

1.接口的方法默认都是public，所有的方法在接口中不能有实现（java8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法。

2.接口中的实例变量默认是final类型，而抽象类中则不一定。

3.一个类可以实现多个接口，但是最多只能实现一个抽象类。

4.一个类可以实现接口的话要实现接口的所有方法，而抽象类不一定。

5.接口不能用new实例化，但是可以声明，但是必须引用一个实现该接口的对象，从设计层面来说，抽象时对类的抽象，是一种模板设计，接口是行为的抽象，时一种行为的规范。



#### 18.成员变量和局部变量的区别有哪些

1.从语法形式上，成员变量是属于类的，而局部变量是在方法中定义的变量或者是方法的参数；成员变量可以被public、private、static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；

2.从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存储在堆内存中，局部变量存储在栈内存

3.从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。

4.成员变量如果没有被赋值，则会自动Ⅰ类型的默认值而赋值（一种情况另外被final修饰的成员变量也必须显示地赋值）；而局部变量则不会被自动赋值。



#### 19.创建一个对象用什么运算符？对象实体与对象引用有何不同？

new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或者1个对象；一个对象可以有n个引用指向它。



#### 20.什么事方法的返回值？返回值在类的方法里的作用是什么？

方法的返回值是指我们获取到的某个方法真能干的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用：接收结果，使得它可以用于其他的操作。

#### 21.一个类的构造方法的作用是什么 若一个类没有声明构造方法，该程序能正确执行码？为什么

主要作用是完成对类对象的初始化工作。可以执行，因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。



#### 22.构造方法有哪些特性

1.名字与类相同

2.没有返回值，但不能用 void 声明构造函数。

3.生成类的对象时自动执行，无需调用。



#### 23.静态方法和实例方法有何不同

1.在外部调用静态方法时，可以使用“类名.方法名”的方式，也可以使用“对象名.方法名”的方式。而实例方法只有后面这种方式，也就是说，调用静态方法可以无需创建对象。

2.静态方法在访问本类成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。



#### 24.对象的相等与指向它们的引用相等，两者有什么不同？

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是它们指向的内存地址是否相等。



#### 25.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是什么

帮助子类做初始化工作。



#### 26.==与 equals

==：它的作用是判断两个对象的地址是否相等。即判断两个对象是不是一个对象。（基本类型==比较的是值，引用类型==比较的是内存地址）。

equals：它的作用也是判断两个对象是否相等。但它一般有两种情况。

​	1.情况1：类没有覆盖 equals（）方法。则通过 equals（）比较该类的两个对象时，等价于通过“==”比较这两个对象。

​	2.情况2：类覆盖了 equals（）方法。一般，我们都覆盖 equals（）方法来比较两个对象的内容相等；若它们的内存相等，则返回 true（认为这两个对象相等）

举个例子

~~~java
public class test{
    public static void main(String[] args){
        String a = new String("ab");//a为一个引用
        String b = new String("ab");//b为另一个引用，对象的内容一样。
        String aa = "ab";//放在常量池中
        String bb = "ab";//从常量池中查找
        
        aa==bb;//true
        a==b;//false 非同一个对象
        
        a.equals(b);//true
        
        42 == 42.0;//true
        
    }
}
~~~

**说明：**

- String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，String 的 equals 方法比较的是对象的值。
- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋值给当前引用。如果没有就在常量池中重新创建一个 String 对象。

#### 27.hashCode 与 equals

面试官可能会问你：“你重写过 hashCode 和 equals 吗，为什么重写 equals 时必须重写 hashCode方法”

**hashCode（）介绍**

hashCode（）的总用是获取哈希码，也成为散列码；它实际上返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode（）定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode 函数。

散列表存储的是键值对（key-value），它的特点是：能够根据“键”快速的检索出对应的“值”。这其中就利用到了散列码（可以快速找到所需要的对象）

**为什么要有 hashCode**

我们以 hashCode 如何检查重复为例子说明为什么要有 hashCode：

当你把对象加入 hashSet 时，HashSet 会先计算对象的 hashCode 的值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，hashSet 会假设对象没有重复出现。但是如果发现相同 hashCode 值得对象，这时就会调用 equals（）方法来检查 hashCode 相等的对象是否真相同。如果这两者相同，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就提高了执行速度。

**hashCode 和 equals（）相关规定**

1.如果两个对象相等，则 hashCode 一定也是相同的。

2.两个对象相等，对两个对象分别调用 equals 方法都返回 true

3.两个对象有相同的 hashCode 值，他们也不一定是相等的。

4.因此，equals 方法被覆盖过，则 hashCode 发放也必须被覆盖。

5.hashCode（）的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode（），则 class 的两个对象无论如何都不会相等（即使两个对象指向的相同的数据）



#### 28.为什么 Java 中只有值传递

[为什么 java 只有值传递](https://github.com/Snailclimb/JavaGuide/blob/master/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/%E6%9C%80%E6%9C%80%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%882018-8-7%EF%BC%89.md)



#### 29.简述线程，程序、进程的基本概念。以及它们之间关系是什么

**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担比进程小的多，也正因为如此，线程也被称为轻量级进程。

**程序**是包含指令和数据的文件，被存储在磁盘或者其他的数据存储设备中，也就是说程序是静态的代码。

**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即使一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令的执行着，同时，每个进程还会占有某些系统资源入 CPU 时间，内存空间，文件、输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中线程极有可能互相影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是同一程序内几乎同时执行一个以上的程序段。



#### 30.线程有哪些基本状态？这些状态是如何定义的？

1.新建（new）：新创建一个线程对象。

2.可运行（runnable）：线程对象创建后，其他线程（比如 main 线程）调用了该对象的 start（）方法。该状态的线程处于可运行线程池中，等待线程调用选中，获取 cpu 的使用权。

3.运行（running）：可运行状态（runnable）的线程获得了 cpu 时间片（timeslice），执行程序代码。

4.阻塞（block）：阻塞状态是指线程因为某种原因放了 cpu 使用权，也让出来 cpu timeslice，暂时停止运行。直到线程进入可运行（runnable）状态，才有机会再次获得 cpu timslice 转到运行（running） 状态。阻塞的情况分三种：（一）。等待阻塞：运行（running）的线程执行 o.wait()方法。JVM 会把该线程放入等待队列（waitting queue） 中。（二）.同步阻塞：运行（running）的线程在获取对象的同步锁时，该同步锁被别的线程占用，JVM 会把该线程放入锁池（lock pool）中。（三).其他阻塞：运行（running）的线程执行 Thread.sleep(long ms)或者 t.join（）方法，或者发出来 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep 状态超时 join 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行（runnable）状态。

5.死亡（dead）：线程 run（）、main（）方法执行结束，或者因异常退出 run 方法，该线程结束了生命周期。死亡的线程不可再次复生。

![](/Users/yanpeng/Documents/pengyand/spring-boot/images/QQ20181220-204505@2x.png)

备注：可以用早起坐地铁来比喻这个过程：

> 还没起床：sleeping
>
> 起床收拾好了，随时可以做地铁出发：runnable
>
> 等地铁来：waiting
>
> 地铁来了，但要排队上地铁：I/O 阻塞
>
> 上来地铁，发现暂时没有座位：synchronized 阻塞
>
> 地铁上找到座位：running
>
> 到达目的地：Dead



#### 31 关于 final 关键字的一些总结

final 关键字主要用在三个地方：变量、方法、类。

1.对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改，如果是引用类型的变量，则在其初始化之后便不能再让其指向另一个对象。

2.当用 final 修饰一个类时，标明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。

3.使用 final 方法的原因有两个。第一个原因是把方法锁定，以防止任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 java 版本已经不需要使用 final 方法进行这些优化了）。类中的所有 private 方法都隐式地指向为 final。



#### 32.Java 中的异常处理

**Java异常类层次结构图**

![](/Users/yanpeng/Documents/pengyand/spring-boot/images/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3634313030332f3230313630372f3634313030332d32303136303730363233323034343238302d3335353335343739302e706e67.png)

在 Java中，所有的异常都有一个共同的祖先java.lang 包中的 Throwable 类。Throwable：有两个重要的子类：Exception（异常）和 Error（错误），两者都是Java 异常处理的重要子类，各自都包含大量子类。



**Error（错误）：**时程序无法处理的错误，表示应用程序中比较严重的问题。大多数错误与代码编写执行时的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择进程终止。

这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 钟，错误通过 Error 的子类描述。

**Exception（异常）：**是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeExcption。RuntimeException 异常由 Java 虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0，抛出该异常）和 ArrayIndexOutOfBoundsException（下标越界异常）。

**注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理的。**

**Throwable 类常用方法**

1. public Stirng getMessage()： 返回异常发生时的详细信息

2. public String toString();返回异常发生时的简要描述

3. public String getLocalizedMessage():返回异常对象本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同。

4. public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息。


**异常处理总结**

- try 块：用于捕获异常。其后可接零个或者多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。
- catch 块：用于处理 try 捕获到的异常。
- finally 块：无论是否捕获或者处理异常，finally 块里的语句都会被执行。当在 try 块或者 catch 块中遇到 return 语句时，finally 语句将在方法返回之前被执行。

**在以下4中特殊情况，finally 块不会被执行**

- finally 语句块中发生了异常。
- 在前面的代码中用了 System.exit()退出程序。
- 程序所在的进程死亡。
- 关闭 CPU



#### 33. Java 序列化中如果有些字段不想被进行序列化怎么办。

对于不想进行序列化的变量，使用 transient 关键字修饰。

transient 关键字的作用:阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。

transient 只能修饰变量，不能修饰类和方法。



#### 34.获取键盘输入常用的两种方法：

方法一：通过 Scanner

~~~java
Scanner input = new Scanner(System.in);
String s = input.nextLine();
input.close();
~~~

方法二：通过 BufferedReader

~~~java
BufferReader input = new BufferedReader(new InputStreamReader(System.in));
String s = input.readLine();
~~~

